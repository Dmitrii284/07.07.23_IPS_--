// Интерфейс ISP
/*
Интерфейс ISP

Преобразование типов
Интерфейсы  - реализуются с помощью абстрактных классов (Без реализации)

Класс -  Это существительное(Выбираем подходящее слово) Длинной 1-3 слова (желательно 1 слово)
 Методы — Лучше называть Глаголами(Осуществляющие какое либо действие)
Название интерфейсов
А_класс → АНазвание

Для Интерфейса — I- Заглавная в начале слова. Затем(или _ или сразу + Прилагательное) I_Printable


Интерфейсы Планируется или нет Ромбовидное наследование. Но их нужно делать с Virtual
Интерфейсы должны быть -- Virtual

У каждого класса должно быть столько интерфейсов Сколько должно быть пользователей
(Сколько веток наследования обращаются к нашему классу)
Пример : Больница
1) Один интерфейс для клиентов
2) Интерфейс для  администратора (записи клиентов)

Пример: Библиотека
1) Интерфейс для Читателей(Выбор книги)
2) Интерфейс для Библиотекаря (Добавить книгу + убрать книги)

При реализации интерфейсов рекомендуется испольхзовать виртуальное Наследование Virtual
В ISP  Смотрим на наличие других классов которые используются ваш

Пример ISP: Построитель карт.
Есть класс Карта он использует 3 класса построителя лабиринта, они все наследники базового абстрактного класса , можно создать еще один интерфейс который допустим будет только для просмотра.  Тоесть класс Базовый Принимает еще одний класс наследника который будет выполнять только для просмотра.

Каждый наследник получает свой набор Инструкций для реализации интерфейса. Это как
Inline функции.

Операторы преобразования типов

staticc_cast<Type>(value) -  Это Статик Каст. (  c_cast Это преобразовывает типы в другие типы на этапе компиляции.)
  Можно подписать для всего этого  c_cast:
1)Virtual_cast
2)Dliname_cast
3)const_cast
4) reinterpret_cast

1)) Virtual_cast Принимает в себя Параметр [*|&] >(A_Type [ Указатель на наследника])
Virtual_cast проверяет что классы наследования связаны между собой
 Чаще всего работают с   Virtual_cast

Virtual_cast<Type> [*|&] >(A_Type [ Указатель на наследника])

3)) const_cast – Это в основном для Хакеров. У переменных есть 2 оператора доступа которые можно применить Это   const или volotill ( Можем заменить  const методы на не  const) Не выходя из класса. (
 const_cast  - Работает так. Же с ссылками и указателями. Мы передаем ссылку в константном виде а получаем в не константном(Либо на оборот)

 const_cast <Type&> (const Type&) - Это не константную ссылку превращаем в константную

volotill _ нужна для того чтобы если кто- то с снаружи поменяет нашу программу , это не вызовет ошибку)

 reinterpret_cast – Она преобразовывает ссылку на любой тип в ссылку на любой тип. (без ответственности Ошибок не будет) Он используется для преобразования указателей)  а 90% случаев это тип void   Если запросить тип данных то Это  *void  .
reinterpret_cast -  Используется для того когда  нужно превратить ссылку на указатель без учета принципов наследования

 ОН Подменяем один указатель на один подменяем на указатель на другой элемент

Dliname_cast             staticc_cast     Они делают одно и тоже только разница в том что Для пользовательских настроек Dliname_cast    -
Библиотеки :
<Tipeinfo> - Позволяет узнавать с чем мы работаем С каким типом данных
<Type – Traids> Позволяет узнать свойство типа данных Или заставить работать без вызова методов этого типа данных


*/


/*
Интерфейсы Типы и Касты
*/

#include<iostream>
#include<typeinfo> //  это иструмент для анализа полученного объекта (анализ тапа анализ Что содержит
#include<type_traits> // можно проверить кто чей наследник (свойство типа данных)
#include<string>
#include<vector>
// Данная задача не сомпилируется т.к.

/*A& ref3 = *p2; - тоже записывает в ссылку адрес  Т.К мы будем пытаться работать через ) указатель Т.К в задаче A* p2 = nullptr;
* Пример 
 nullptr; - запрещена из-за контроля ошибок внутри кода 
*/
//class A
//{
//public:
//	virtual ~A(){ }
//
//};
//
//class B : public A
//{
//public:
//	~B() override{ }
//
//};
//
//int main()
//{
//	A* p = new B;
//	A* p2 = nullptr;
//	A* p3 = new A;
//
//	A& ref = *p;
//	A& ref2 = *p3;
//	A& ref3 = *p2;
//	*nullptr;
//
//	return{};
//}
/*
Rantame Error 

#include<typeinfo> - Очень важно проверять то что сделал разработчик CPP -Referenc Сайт
*/

//// Работа с кастами разного типа

//class A
//{
//public:
//	virtual ~A() { }
//
//};
//
//class B : public A
//{
//public:
//	~B() override { }
//
//};
//
//int main()
//{
//	A* p = new B;
//	A* p2 = nullptr; // При работе с отладчиком Фото Мы получили ошибку ТК указатель на 0
//	A* p3 = new A;
//
//	A& ref = *p;
//	A& ref2 = *p3;
//	A& ref3 = *p2;
//
//	std::string tmp = typeid(*p).name();
//	// Ловим нашу ошибку
//	try {
//		tmp = typeid(*p2).name();
//	}
//	catch(...) { std::cerr << "everything fine, NO\n"; }
//
//
////	tmp = typeid(*p2).name(); // При работе с отладчиком Фото Мы получили ошибку ТК указатель на 0		
//	tmp = typeid(*p3).name();
//	tmp = typeid(ref).name();
//	tmp = typeid(ref2).name();
//	
//	return{};
//}

// является ли абстрактным Класс А   std::is_abstract<A>();

//class A
//{
//	int var;
//public:
//	//A() = delete;
//	A() = default;
//	A(int a):var(a){ }
//	void F00() {
//		var = 4;
//	}
//	virtual ~A(){ }
//};
//
//class B : public A
//{
//public:
//	B() : A(0) { } 
//	~B() override { }
//
//};
//
//int main()
//{
//	A* p = new B;
//	A* p2 = nullptr; // При работе с отладчиком Фото Мы получили ошибку ТК указатель на 0
//	A* p3 = new A{ 3 };
//
//	A& ref = *p;
//	A& ref2 = *p3;
//  //	A& ref3 = *p2;
//
//	std::vector<A> arr;
//	arr.reserve(10);
//	std::vector<A> arr2(10);
//
//	std::string tmp = typeid(*p).name();
//	// Ловим нашу ошибку
//	try {
//		tmp = typeid(*p2).name();
//	}
//	catch(...) { std::cerr << "everything fine, NO\n"; }
//
//
//
//	tmp = typeid(*p3).name();
//	tmp = typeid(ref).name();
//	tmp = typeid(ref2).name();
//	std::is_abstract<A>();
//	static_assert // если пришла истина то код прошол если лож то код не прошол
//
//	return{};
//}



// static_assert Для того чтобы узнать наворотили мы с программой или нет
// трэйты
// hash - кодирует любой тип данных в для сравнения типов данных. Допустим что больше или меньше Предназначен для кодировки 
// hash Применяются для ускорения алгоритмических проверок для сравнения типов И контроль безопасности данных. 
// hash ОНА ДО УСТАНОВКИ ПОЗВОЛЯЕТ ОПРЕДЕЛИТЬ ЧТО СКАЧАННАЯ ПРОГРАММА ПОЛОМАНА ИЛИ НЕТ ПО ДЛИННЕ СИМВОЛОВ. дО УСТАНОВКИ ЕЕ.
// сравниваются все синие типы данных

//class A
//{
//	int var;
//public:
//	//A() = delete;
//	A() = default;
//	A(int a):var(a){ }
//	void F00() {
//		var = 4;
//	}
//	virtual ~A(){ }
//};
//
//class B : public A
//{
//public:
//	B() : A(0) { } 
//	~B() override { }
//
//};
//
//int main()
//{
//	A* p = new B;
//	A* p2 = nullptr; // При работе с отладчиком Фото Мы получили ошибку ТК указатель на 0
//	A* p3 = new A{ 3 };
//
//	A& ref = *p;
//	A& ref2 = *p3;
//  //	A& ref3 = *p2;
//
//	std::vector<A> arr;
//	arr.reserve(10);
//	std::vector<A> arr2(10);
//
//	std::string tmp = typeid(*p).name();
//	// Ловим нашу ошибку
//	try {
//		tmp = typeid(*p2).name();
//	}
//	catch(...) { std::cerr << "everything fine, NO\n"; }
//
//
//
//	tmp = typeid(*p3).name();
//	tmp = typeid(ref).name();
//	tmp = typeid(ref2).name();
//	bool res = std::is_abstract<A>(); 
//	// Те трэйты которые начинаются с is - всегда предикаты и возвращают булевые значения 
//	//static_assert(std::is_abstract<A>());
//	 // если пришла истина то код прошол если лож то код не прошол
//
//	std::hash<int>()(1);
//
//
//	return{};
//}

// IPrinteble - Обрубаем возможность наследников Но Интерфейс наормально работает.
// плохо удалять элементы

/*
IPrinteble() = delete; // Удаляем конструктор Их вызов заблокирован для потомков
	~IPrinteble() = delete; // Удаляем деструктор Их вызов заблокирован для потомков

	Как только Эту запись уберем все заработает
*/
//
//class IPrinteble
//{
//public:
//	virtual void Print() const = 0;
//	IPrinteble() = delete; // Удаляем конструктор Их вызов заблокирован для потомков
//	~IPrinteble() = delete; // Удаляем деструктор Их вызов заблокирован для потомков
//};
//
//class A : virtual public IPrinteble
//{
//	int var;
//public:
//	//A() = delete;
//	A() = default;
//	A(int a) :var(a) { }
//	void F00() {
//		var = 4;
//	}
//	virtual ~A() { }
//
//	void Print() const override
//	{
//		std::cout << "var" << var << std::endl;
//	}
//
//};
//
//class B : public A
//{
//public:
//	B() : A(0) { }
//	~B() override { }
//
//	void Bar(const IPrinteble& obj)
//	{
//		obj.Print();
//	}
//};
//
//int main()
//{
//	A* p = new B;
//	A* p2 = nullptr; // При работе с отладчиком Фото Мы получили ошибку ТК указатель на 0
//	A* p3 = new A{ 3 };
//
//	A& ref = *p;
//	A& ref2 = *p3;
//	//	A& ref3 = *p2;
//
//	std::vector<A> arr;
//	arr.reserve(10);
//	std::vector<A> arr2(10);
//
//	std::string tmp = typeid(*p).name();
//	// Ловим нашу ошибку
//	try {
//		tmp = typeid(*p2).name();
//	}
//	catch (...) { std::cerr << "everything fine, NO\n"; }
//
//
//
//	tmp = typeid(*p3).name();
//	tmp = typeid(ref).name();
//	tmp = typeid(ref2).name();
//	bool res = std::is_abstract<A>();
//	// Те трэйты которые начинаются с is - всегда предикаты и возвращают булевые значения 
//	//static_assert(std::is_abstract<A>());
//	 // если пришла истина то код прошол если лож то код не прошол
//
//	std::hash<int>()(1);
//
//
//	return{};
//}

// IPrinteble   создадим Функцию  Глобальную  void Bar(const IPrinteble& obj)
// Интерфейсы это маленькие наборры команд   
/*
Создадим функции которые принимают один и тот же obj И заставляем выполнять  функцию в разных классах 
*/

class IPrinteble
{
public:
	virtual void Print() const = 0;
	//IPrinteble() = delete; // Удаляем конструктор Их вызов заблокирован для потомков
	//~IPrinteble() = delete; // Удаляем деструктор Их вызов заблокирован для потомков
};

// Пример проверки
class IF00
{
public:
	virtual void F00() = 0;
};

class A : virtual public IPrinteble, virtual public IF00
{
	int var;
public:
	//A() = delete;
	A() = default;
	A(int a) :var(a) { }
	void F00() {
		var = 4;
	}
	virtual ~A() { }

	void Print() const override
	{
		std::cout << "var" << var << std::endl;
	}

};


class B : public A // Наследует класс А и реализует 2 интерфейса
{
public:
	B() : A(0) { }
	~B() override { }
};

void Bar(const IPrinteble& obj)
	{
		obj.Print();
	}

void Bar2(IF00& obj)
{
	std::string tmp = typeid(obj).name();
	obj.F00();
}

int main()
{
	A* p = new B;
	A* p2 = nullptr; // При работе с отладчиком Фото Мы получили ошибку ТК указатель на 0
	A* p3 = new A{ 3 };

	A& ref = *p;
	A& ref2 = *p3;
	//	A& ref3 = *p2;

	Bar(*p);
	Bar(*p3);
	Bar(ref);
	Bar(ref2);
	
	Bar2(*p);
	Bar2(*p3);
	Bar2(ref);
	Bar2(ref2);


	std::vector<A> arr;
	arr.reserve(10);
	std::vector<A> arr2(10);

	std::string tmp = typeid(*p).name();
	// Ловим нашу ошибку
	try {
		tmp = typeid(*p2).name();
	}
	catch (...) { std::cerr << "everything fine, NO\n"; }



	tmp = typeid(*p3).name();
	tmp = typeid(ref).name();
	tmp = typeid(ref2).name();
	bool res = std::is_abstract<A>();
	// Те трэйты которые начинаются с is - всегда предикаты и возвращают булевые значения 
	//static_assert(std::is_abstract<A>());
	 // если пришла истина то код прошол если лож то код не прошол

	std::hash<int>()(1);


	return{};
}